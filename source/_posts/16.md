---
title: å…¼å®¹çš„èœå•ç³»ç»Ÿ
date: 2025-12-25 15:05:40
tags:
---
```rust
use bevy::prelude::*;
use bevy::window::WindowResized;
use crate::raven::bevy_integration::{CanvasConfig, VirtualScreenScale, ScalableUI};

pub struct MenuPlugin;

impl Plugin for MenuPlugin {
    fn build(&self, app: &mut App) {
        println!(" MenuPlugin æ­£åœ¨æ„å»º...");
        app
            .add_systems(OnEnter(crate::raven::bevy_integration::GameState::Menu), setup_menu)
            .add_systems(Update, (handle_buttons, handle_input, menu_window_resize_system).run_if(in_state(crate::raven::bevy_integration::GameState::Menu)))
            .add_systems(OnExit(crate::raven::bevy_integration::GameState::Menu), cleanup_menu);
    }
}

#[derive(Component)]
struct MenuUI;

#[derive(Component)]
struct VirtualScreen;  // ğŸ†• è™šæ‹Ÿå±å¹•æ ‡è®°ç»„ä»¶

#[derive(Component)]
struct MenuBackground; 

#[derive(Component)]
struct StartButton;

#[derive(Component)]
struct ExitButton;

fn setup_menu(mut commands: Commands, camera_query: Query<Entity, With<Camera2d>>, asset_server: Res<AssetServer>) {
    if camera_query.is_empty() {
        commands.spawn(Camera2d);
    }

    // ğŸ†• åˆ›å»ºè™šæ‹Ÿå±å¹•å®¹å™¨ï¼Œå¹¶å°†æ‰€æœ‰UIä½œä¸ºå…¶å­èŠ‚ç‚¹
    commands
        .spawn((
            Node {
                width: Val::Px(1920.0), // è™šæ‹Ÿå±å¹•å®½åº¦
                height: Val::Px(1080.0), // è™šæ‹Ÿå±å¹•é«˜åº¦
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::FlexEnd,
                ..default()
            },
            BackgroundColor(Color::BLACK),
            GlobalZIndex(100),
            VirtualScreen,  // ğŸ†• è™šæ‹Ÿå±å¹•æ ‡è®°
            MenuUI,
            ScalableUI::new().with_size(1920.0, 1080.0),
        ))
        .with_children(|virtual_screen| {
            // ğŸ†• åœ¨è™šæ‹Ÿå±å¹•å†…åˆ›å»ºèœå•UIå®¹å™¨
            virtual_screen.spawn((
                Node {
                    width: Val::Px(720.0), 
                    height: Val::Px(1080.0),
                    align_items: AlignItems::Center,
                    justify_content: JustifyContent::Center,
                    flex_direction: FlexDirection::Column,
                    position_type: PositionType::Absolute,
                    top: Val::Px(0.0),
                    left: Val::Px(0.0),
                    ..default()
                },
                MenuUI,
                ScalableUI::new().with_size(720.0, 1080.0),
            )).with_children(|menu_container| {
                // æ ‡é¢˜
                menu_container.spawn((
                    Text::new("Raven Engine"),
                    TextFont { font_size: 48.0, ..default() },
                    TextColor(Color::WHITE),
                    Node {
                        margin: UiRect::bottom(Val::Px(30.0)),
                        ..default()
                    },
                    MenuUI,
                    ScalableUI::new().with_font_size(48.0),
                ));  
                
                // å¼€å§‹æŒ‰é’®
                menu_container.spawn((
                    Button,
                    Node {
                        width: Val::Px(200.0),
                        height: Val::Px(50.0),
                        margin: UiRect::all(Val::Px(40.0)),
                        align_items: AlignItems::Center,
                        justify_content: JustifyContent::Center,
                        border: UiRect::all(Val::Px(2.0)),
                        ..default()
                    },
                    BackgroundColor(Color::srgb(0.2, 0.5, 0.2)),
                    StartButton,
                    MenuUI,
                    ScalableUI::new().with_size(200.0, 50.0),
                )).with_children(|button| {
                    button.spawn((
                        Text::new("Start Game"),
                        TextFont { font_size: 20.0, ..default() },
                        TextColor(Color::WHITE),
                        MenuUI,
                        ScalableUI::new().with_font_size(20.0),
                    ));
                });
                
                // é€€å‡ºæŒ‰é’®
                menu_container.spawn((
                    Button,
                    Node {
                        width: Val::Px(200.0),
                        height: Val::Px(50.0),
                        margin: UiRect::all(Val::Px(10.0)),
                        align_items: AlignItems::Center,
                        justify_content: JustifyContent::Center,
                        border: UiRect::all(Val::Px(2.0)),
                        ..default()
                    },
                    BackgroundColor(Color::srgb(0.5, 0.2, 0.2)),
                    ExitButton,
                    MenuUI,
                    ScalableUI::new().with_size(200.0, 50.0),
                )).with_children(|button| {
                    button.spawn((
                        Text::new("Exit"),
                        TextFont { font_size: 20.0, ..default() },
                        TextColor(Color::WHITE),
                        MenuUI,
                        ScalableUI::new().with_font_size(20.0),
                    ));
                });
            });
        });

    // èƒŒæ™¯å›¾ç‰‡ï¼ˆ2Dç²¾çµï¼Œç‹¬ç«‹äºUIç³»ç»Ÿï¼‰
    commands.spawn((
        Sprite {
            image: asset_server.load("gui/main_menu.png"),
            custom_size: Some(Vec2::new(1920.0, 1080.0)),
            ..default()
        },
        Transform::from_translation(Vec3::new(0.0, 0.0, 0.3)), 
        MenuBackground,
        MenuUI,
    ));

    commands.spawn((
        Sprite {
            image: asset_server.load("gui/game3.png"),
            custom_size: Some(Vec2::new(1920.0, 1080.0)),
            ..default()
        },
        Transform::from_translation(Vec3::new(0.0, 0.0, 0.2)),
        MenuUI,
    ));
}

// å…¶ä½™å‡½æ•°ä¿æŒä¸å˜...
fn menu_window_resize_system(
    mut resize_events: EventReader<WindowResized>,
    mut camera_query: Query<&mut Projection, With<Camera2d>>,
    mut ui_query: Query<(&mut Node, &ScalableUI), Without<Text>>,
    mut text_query: Query<(&mut TextFont, &ScalableUI), With<Text>>,
    canvas_config: Res<CanvasConfig>,
    mut virtual_scale: ResMut<VirtualScreenScale>,
) {
    for event in resize_events.read() {
        let window_width = event.width;
        let window_height = event.height;
        let virtual_width = canvas_config.width;
        let virtual_height = canvas_config.height;

        // è®¡ç®—ç­‰æ¯”ç¼©æ”¾
        let scale_x = window_width / virtual_width;
        let scale_y = window_height / virtual_height;
        let scale = scale_x.min(scale_y);

        // è®¡ç®—å±…ä¸­åç§»
        let scaled_width = virtual_width * scale;
        let scaled_height = virtual_height * scale;
        let offset_x = (window_width - scaled_width) / 2.0;
        let offset_y = (window_height - scaled_height) / 2.0;

        // æ›´æ–°ç¼©æ”¾èµ„æº
        virtual_scale.scale = scale;
        virtual_scale.offset_x = offset_x;
        virtual_scale.offset_y = offset_y;

        // æ›´æ–°æ‘„åƒæœºï¼ˆ2Dç²¾çµç¼©æ”¾ï¼‰
        let camera_scale = 1.0 / scale;
        for mut projection in camera_query.iter_mut() {
            if let Projection::Orthographic(ortho) = projection.as_mut() {
                ortho.scale = camera_scale;
            }
        }

        // æ›´æ–°UIèŠ‚ç‚¹
        for (mut node, scalable_ui) in ui_query.iter_mut() {
            if scalable_ui.original_width > 0.0 {
                node.width = Val::Px(scalable_ui.original_width * scale);
            }
            if scalable_ui.original_height > 0.0 {
                node.height = Val::Px(scalable_ui.original_height * scale);
            }

            node.margin = scale_ui_rect(&scalable_ui.original_margin, scale);
            node.padding = scale_ui_rect(&scalable_ui.original_padding, scale);
            node.border = scale_ui_rect(&scalable_ui.original_border, scale);

            // ğŸ†• åªä¸ºæ ¹è™šæ‹Ÿå±å¹•å®¹å™¨è®¾ç½®åç§»
            if scalable_ui.original_width == virtual_width && scalable_ui.original_height == virtual_height {
                node.left = Val::Px(offset_x);
                node.top = Val::Px(offset_y);
            }
        }

        // æ›´æ–°æ–‡æœ¬å¤§å°
        for (mut text_font, scalable_ui) in text_query.iter_mut() {
            if let Some(original_font_size) = scalable_ui.original_font_size {
                text_font.font_size = original_font_size * scale;
            }
        }

        println!("èœå•ç¼©æ”¾: scale={:.3}, offset=({:.1}, {:.1})", scale, offset_x, offset_y);
    }
}

// è¾…åŠ©å‡½æ•°
fn scale_ui_rect(rect: &UiRect, scale: f32) -> UiRect {
    UiRect {
        left: scale_val(&rect.left, scale),
        right: scale_val(&rect.right, scale),
        top: scale_val(&rect.top, scale),
        bottom: scale_val(&rect.bottom, scale),
    }
}

fn scale_val(val: &Val, scale: f32) -> Val {
    match val {
        Val::Px(px) => Val::Px(*px * scale),
        Val::Percent(percent) => Val::Percent(*percent),
        _ => *val,
    }
}

fn handle_buttons(
    mut interaction_query: Query<(&Interaction, Option<&StartButton>, Option<&ExitButton>), (Changed<Interaction>, With<Button>)>,
    mut next_state: ResMut<NextState<crate::raven::bevy_integration::GameState>>,
) {
    for (interaction, start_button, exit_button) in &mut interaction_query {
        if *interaction == Interaction::Pressed {
            if start_button.is_some() {
                println!("ğŸ® å¼€å§‹æŒ‰é’®è¢«ç‚¹å‡»");
                next_state.set(crate::raven::bevy_integration::GameState::Playing);
            } else if exit_button.is_some() {
                println!(" é€€å‡ºæŒ‰é’®è¢«ç‚¹å‡»");
                std::process::exit(0);
            }
        }
    }
}

fn handle_input(
    keys: Res<ButtonInput<KeyCode>>,
    mut next_state: ResMut<NextState<crate::raven::bevy_integration::GameState>>,
) {
    if keys.just_pressed(KeyCode::Enter) {
        println!("âŒ¨ï¸ ENTER é”®è¢«æŒ‰ä¸‹ï¼Œå¼€å§‹æ¸¸æˆ");
        next_state.set(crate::raven::bevy_integration::GameState::Playing);
    } else if keys.just_pressed(KeyCode::Escape) {
        println!("âŒ¨ï¸ ESC é”®è¢«æŒ‰ä¸‹ï¼Œé€€å‡ºæ¸¸æˆ");
        std::process::exit(0);
    }
}

fn cleanup_menu(
    mut commands: Commands, 
    query: Query<Entity, With<MenuUI>>,
    bg_query: Query<Entity, With<MenuBackground>>,
) {
    println!("æ­£åœ¨æ¸…ç†èœå•...");
    
    for entity in &query {
        println!("åˆ é™¤èœå•å®ä½“: {:?}", entity);
        commands.entity(entity).despawn();  // ğŸ†• ä½¿ç”¨é€’å½’åˆ é™¤
    }
    
    for entity in &bg_query {
        commands.entity(entity).despawn();
    }
    
    println!(" èœå•æ¸…ç†å®Œæˆ");
}
```