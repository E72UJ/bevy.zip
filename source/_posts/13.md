---
title: æ˜¾ç¤ºå†…å®¹æ•°æ®
date: 2025-12-17 05:29:02
tags:
---

```rust
// src/main.rs
use bevy::prelude::*;
use bevy::ui::*;
use std::collections::HashMap;
use std::time::Instant;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "Raven Test - å†…å­˜ç›‘æ§".into(),
                resolution: (1200u32, 800u32).into(),
                ..default()
            }),
            ..default()
        }))
        
        .add_systems(Startup, setup)
        .add_systems(Update, (
            load_assets_system,
            memory_monitor_system,
            input_handler,
            ui_system,
            display_images,
        ))
        
        .run();
}



// èµ„æºå®šä¹‰
#[derive(Resource)]
struct RavenAssets {
    // èƒŒæ™¯å›¾ç‰‡
    backgrounds: HashMap<String, Handle<Image>>,
    
    // è§’è‰²å›¾ç‰‡ï¼ˆæŒ‰é¢œè‰²å’Œè¡¨æƒ…åˆ†ç±»ï¼‰
    sylvie_blue: HashMap<String, Handle<Image>>,
    sylvie_green: HashMap<String, Handle<Image>>,
    
    // åŠ è½½çŠ¶æ€
    loading_status: LoadingStatus,
    load_start_time: Option<Instant>,
}

#[derive(PartialEq)]
enum LoadingStatus {
    NotStarted,
    Loading,
    Completed,
    Error(String),
}

#[derive(Resource)]
struct MemoryMonitor {
    last_update: f32,
    memory_history: Vec<f32>, // å†…å­˜ä½¿ç”¨å†å²
    max_history: usize,
}

#[derive(Resource)]
struct DisplayState {
    current_background: Option<String>,
    current_character: Option<String>,
    show_ui: bool,
}

// UIç»„ä»¶æ ‡è®°
#[derive(Component)]
struct MemoryText;

#[derive(Component)]
struct StatusText;

#[derive(Component)]
struct InstructionText;

#[derive(Component)]
struct BackgroundSprite;

#[derive(Component)]
struct CharacterSprite;

fn setup(mut commands: Commands) {
    // ç›¸æœº
    commands.spawn(Camera2d::default());
    
    // åˆå§‹åŒ–èµ„æº
    commands.insert_resource(RavenAssets {
        backgrounds: HashMap::new(),
        sylvie_blue: HashMap::new(),
        sylvie_green: HashMap::new(),
        loading_status: LoadingStatus::NotStarted,
        load_start_time: None,
    });
    
    commands.insert_resource(MemoryMonitor {
        last_update: 0.0,
        memory_history: Vec::new(),
        max_history: 60, // ä¿å­˜60æ¬¡è®°å½•
    });
    
    commands.insert_resource(DisplayState {
        current_background: None,
        current_character: None,
        show_ui: true,
    });
    
    println!("\nğŸ® Raven Test å¯åŠ¨");
    println!("ğŸ“‚ èµ„æºç›®å½•: assets/images/");
    println!("========== å¿«æ·é”®è¯´æ˜ ==========");
    println!("  L  â†’ å¼€å§‹åŠ è½½æ‰€æœ‰èµ„æº");
    println!("  M  â†’ åˆ‡æ¢å†…å­˜æ˜¾ç¤ºUI");
    println!("  1-4 â†’ åˆ‡æ¢èƒŒæ™¯å›¾ç‰‡");
    println!("  Q  â†’ Sylvieè“è‰²-æ™®é€š");
    println!("  W  â†’ Sylvieè“è‰²-å¾®ç¬‘");
    println!("  E  â†’ Sylvieç»¿è‰²-æ™®é€š");
    println!("  R  â†’ Sylvieç»¿è‰²-å’¯å’¯ç¬‘");
    println!("  C  â†’ æ¸…é™¤æ‰€æœ‰æ˜¾ç¤º");
    println!("===============================\n");
}

fn load_assets_system(
    mut assets: ResMut<RavenAssets>,
    asset_server: Res<AssetServer>,
    input: Res<ButtonInput<KeyCode>>,
) {
    // æŒ‰Lé”®å¼€å§‹åŠ è½½
    if input.just_pressed(KeyCode::KeyL) && assets.loading_status == LoadingStatus::NotStarted {
        println!("\nğŸ”„ å¼€å§‹åŠ è½½æ‰€æœ‰èµ„æº...");
        assets.loading_status = LoadingStatus::Loading;
        assets.load_start_time = Some(Instant::now());
        
        // åŠ è½½èƒŒæ™¯å›¾ç‰‡
        println!("ğŸ“‚ åŠ è½½èƒŒæ™¯å›¾ç‰‡...");
        assets.backgrounds.insert(
            "club".to_string(),
            asset_server.load("images/bg club.jpg")
        );
        assets.backgrounds.insert(
            "lecturehall".to_string(),
            asset_server.load("images/bg lecturehall.jpg")
        );
        assets.backgrounds.insert(
            "meadow".to_string(),
            asset_server.load("images/bg meadow.jpg")
        );
        assets.backgrounds.insert(
            "uni".to_string(),
            asset_server.load("images/bg uni.jpg")
        );
        println!("   âœ… å·²è¯·æ±‚åŠ è½½4å¼ èƒŒæ™¯å›¾");
        
        // åŠ è½½Sylvieè“è‰²ç³»åˆ—
        println!("ğŸ‘¥ åŠ è½½Sylvieè“è‰²ç³»åˆ—...");
        assets.sylvie_blue.insert(
            "giggle".to_string(),
            asset_server.load("images/sylvie blue giggle.png")
        );
        assets.sylvie_blue.insert(
            "normal".to_string(),
            asset_server.load("images/sylvie blue normal.png")
        );
        assets.sylvie_blue.insert(
            "smile".to_string(),
            asset_server.load("images/sylvie blue smile.png")
        );
        assets.sylvie_blue.insert(
            "surprised".to_string(),
            asset_server.load("images/sylvie blue surprised.png")
        );
        println!("   âœ… å·²è¯·æ±‚åŠ è½½4å¼ è“è‰²Sylvie");
        
        // åŠ è½½Sylvieç»¿è‰²ç³»åˆ—
        println!("ğŸ‘¥ åŠ è½½Sylvieç»¿è‰²ç³»åˆ—...");
        assets.sylvie_green.insert(
            "giggle".to_string(),
            asset_server.load("images/sylvie green giggle.png")
        );
        assets.sylvie_green.insert(
            "normal".to_string(),
            asset_server.load("images/sylvie green normal.png")
        );
        assets.sylvie_green.insert(
            "smile".to_string(),
            asset_server.load("images/sylvie green smile.png")
        );
        assets.sylvie_green.insert(
            "surprised".to_string(),
            asset_server.load("images/sylvie green surprised.png")
        );
        println!("   âœ… å·²è¯·æ±‚åŠ è½½4å¼ ç»¿è‰²Sylvie");
        
        println!("ğŸ“Š æ€»è®¡: 12å¼ å›¾ç‰‡å·²å¼€å§‹å¼‚æ­¥åŠ è½½\n");
    }
}

fn memory_monitor_system(
    mut monitor: ResMut<MemoryMonitor>,
    time: Res<Time>,
    mut assets: ResMut<RavenAssets>,
    images: Res<Assets<Image>>,
) {
    let current_time = time.elapsed_secs();
    
    // æ¯0.5ç§’æ›´æ–°ä¸€æ¬¡å†…å­˜ä¿¡æ¯
    if current_time - monitor.last_update > 0.5 {
        monitor.last_update = current_time;
        
        // è®¡ç®—GPUæ˜¾å­˜ä½¿ç”¨
        let mut gpu_memory = 0;
        let mut image_count = 0;
        let mut image_details = Vec::new();
        
        for (_id, image) in images.iter() {
            let width = image.texture_descriptor.size.width;
            let height = image.texture_descriptor.size.height;
            
            let bytes_per_pixel = match image.texture_descriptor.format {
                bevy::render::render_resource::TextureFormat::Rgba8Unorm => 4,
                bevy::render::render_resource::TextureFormat::Bgra8Unorm => 4,
                _ => 4,
            };
            
            let image_memory = width * height * bytes_per_pixel;
            gpu_memory += image_memory;
            image_count += 1;
            
            let mb = image_memory as f32 / 1024.0 / 1024.0;
            image_details.push((width, height, mb));
        }
        
        let gpu_mb = gpu_memory as f32 / 1024.0 / 1024.0;
        
        // æ·»åŠ åˆ°å†å²è®°å½•
        monitor.memory_history.push(gpu_mb);
        if monitor.memory_history.len() > monitor.max_history {
            monitor.memory_history.remove(0);
        }
        
        // æ¯2ç§’æ‰“å°ä¸€æ¬¡è¯¦ç»†ä¿¡æ¯
        if (current_time as i32) % 2 == 0 && current_time - monitor.last_update < 0.6 {
            println!("========== å†…å­˜ç›‘æ§æŠ¥å‘Š ==========");
            println!("â±ï¸  è¿è¡Œæ—¶é—´: {:.1}ç§’", current_time);
            println!("ğŸ® GPUæ˜¾å­˜ä½¿ç”¨: {:.1} MB ({} å¼ å›¾ç‰‡)", gpu_mb, image_count);
            
            for (i, (w, h, mb)) in image_details.iter().enumerate() {
                println!("   ğŸ–¼ï¸  å›¾ç‰‡{}: {}Ã—{} = {:.2}MB", i + 1, w, h, mb);
            }
            
            // å†…å­˜å˜åŒ–è¶‹åŠ¿
            if monitor.memory_history.len() > 1 {
                let prev = monitor.memory_history[monitor.memory_history.len() - 2];
                let change = gpu_mb - prev;
                let trend = if change > 0.1 { "ğŸ“ˆ ä¸Šå‡" } 
                           else if change < -0.1 { "ğŸ“‰ ä¸‹é™" } 
                           else { "â¡ï¸  ç¨³å®š" };
                println!("ğŸ“Š å†…å­˜å˜åŒ–: {} ({:+.1}MB)", trend, change);
            }
            
            // å†…å­˜è­¦å‘Š
            if gpu_mb > 100.0 {
                println!("âš ï¸  GPUæ˜¾å­˜ä½¿ç”¨è¾ƒé«˜: {:.1}MB", gpu_mb);
            }
            if gpu_mb > 200.0 {
                println!("ğŸš¨ GPUæ˜¾å­˜ä½¿ç”¨è¿‡é«˜: {:.1}MB!", gpu_mb);
            }
            
            println!("==================================\n");
        }
        
        // æ£€æŸ¥åŠ è½½çŠ¶æ€
        if assets.loading_status == LoadingStatus::Loading {
            check_loading_completion(&mut assets, &images);
        }
    }
}

fn check_loading_completion(assets: &mut RavenAssets, images: &Assets<Image>) {
    let total_expected = 12; // 4èƒŒæ™¯ + 4è“è‰² + 4ç»¿è‰²
    let mut loaded_count = 0;
    
    // æ£€æŸ¥èƒŒæ™¯å›¾ç‰‡
    for (_name, handle) in &assets.backgrounds {
        if images.get(handle).is_some() {
            loaded_count += 1;
        }
    }
    
    // æ£€æŸ¥è§’è‰²å›¾ç‰‡
    for (_name, handle) in &assets.sylvie_blue {
        if images.get(handle).is_some() {
            loaded_count += 1;
        }
    }
    
    for (_name, handle) in &assets.sylvie_green {
        if images.get(handle).is_some() {
            loaded_count += 1;
        }
    }
    
    if loaded_count == total_expected {
        if let Some(start_time) = assets.load_start_time {
            let elapsed = start_time.elapsed();
            println!("\nğŸ‰ æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆï¼");
            println!("â±ï¸  åŠ è½½è€—æ—¶: {:.2}ç§’", elapsed.as_secs_f32());
            println!("âœ… ç°åœ¨å¯ä»¥æŒ‰ 1-4 åˆ‡æ¢èƒŒæ™¯ï¼ŒQ-R åˆ‡æ¢è§’è‰²\n");
            assets.loading_status = LoadingStatus::Completed;
        }
    } else {
        println!("â³ åŠ è½½è¿›åº¦: {}/{}", loaded_count, total_expected);
    }
}

fn input_handler(
    input: Res<ButtonInput<KeyCode>>,
    mut display_state: ResMut<DisplayState>,
    assets: Res<RavenAssets>,
) {
    // åˆ‡æ¢UIæ˜¾ç¤º
    if input.just_pressed(KeyCode::KeyM) {
        display_state.show_ui = !display_state.show_ui;
        println!("ğŸ–¥ï¸  UIæ˜¾ç¤º: {}", if display_state.show_ui { "âœ… å¼€å¯" } else { "âŒ å…³é—­" });
    }
    
    // åªæœ‰åŠ è½½å®Œæˆåæ‰èƒ½åˆ‡æ¢å›¾ç‰‡
    if assets.loading_status != LoadingStatus::Completed {
        return;
    }
    
    // åˆ‡æ¢èƒŒæ™¯ (1-4)
    if input.just_pressed(KeyCode::Digit1) {
        display_state.current_background = Some("club".to_string());
        println!("ğŸ« èƒŒæ™¯: ä¿±ä¹éƒ¨");
    }
    if input.just_pressed(KeyCode::Digit2) {
        display_state.current_background = Some("lecturehall".to_string());
        println!("ğŸ“ èƒŒæ™¯: è®²å ‚");
    }
    if input.just_pressed(KeyCode::Digit3) {
        display_state.current_background = Some("meadow".to_string());
        println!("ğŸŒ¿ èƒŒæ™¯: è‰åœ°");
    }
    if input.just_pressed(KeyCode::Digit4) {
        display_state.current_background = Some("uni".to_string());
        println!("ğŸ›ï¸  èƒŒæ™¯: å¤§å­¦");
    }
    
    // åˆ‡æ¢è§’è‰²è¡¨æƒ…
    if input.just_pressed(KeyCode::KeyQ) {
        display_state.current_character = Some("blue_normal".to_string());
        println!("ğŸ‘§ è§’è‰²: Sylvieè“è‰² - æ™®é€š");
    }
    if input.just_pressed(KeyCode::KeyW) {
        display_state.current_character = Some("blue_smile".to_string());
        println!("ğŸ˜Š è§’è‰²: Sylvieè“è‰² - å¾®ç¬‘");
    }
    if input.just_pressed(KeyCode::KeyE) {
        display_state.current_character = Some("green_normal".to_string());
        println!("ğŸ‘© è§’è‰²: Sylvieç»¿è‰² - æ™®é€š");
    }
    if input.just_pressed(KeyCode::KeyR) {
        display_state.current_character = Some("green_giggle".to_string());
        println!("ğŸ˜„ è§’è‰²: Sylvieç»¿è‰² - å’¯å’¯ç¬‘");
    }
    
    // æ¸…é™¤æ˜¾ç¤º
    if input.just_pressed(KeyCode::KeyC) {
        display_state.current_background = None;
        display_state.current_character = None;
        println!("ğŸ§¹ æ¸…é™¤æ‰€æœ‰æ˜¾ç¤º");
    }
}

fn display_images(
    mut commands: Commands,
    display_state: Res<DisplayState>,
    assets: Res<RavenAssets>,
    query_bg: Query<Entity, With<BackgroundSprite>>,
    query_char: Query<Entity, With<CharacterSprite>>,
) {
    // æ¸…é™¤æ—§çš„èƒŒæ™¯
    for entity in &query_bg {
        commands.entity(entity).despawn();
    }
    
    // æ˜¾ç¤ºæ–°èƒŒæ™¯
    if let Some(bg_name) = &display_state.current_background {
        if let Some(handle) = assets.backgrounds.get(bg_name) {
            commands.spawn((
                Sprite {
                    image: handle.clone(),
                    custom_size: Some(Vec2::new(1200.0, 800.0)),
                    ..default()
                },
                Transform::from_translation(Vec3::new(0.0, 0.0, -1.0)),
                BackgroundSprite,
            ));
        }
    }
    
    // æ¸…é™¤æ—§çš„è§’è‰²
    for entity in &query_char {
        commands.entity(entity).despawn();
    }
    
    // æ˜¾ç¤ºæ–°è§’è‰²
    if let Some(char_name) = &display_state.current_character {
        let handle = if char_name.starts_with("blue_") {
            let emotion = char_name.strip_prefix("blue_").unwrap();
            assets.sylvie_blue.get(emotion)
        } else if char_name.starts_with("green_") {
            let emotion = char_name.strip_prefix("green_").unwrap();
            assets.sylvie_green.get(emotion)
        } else {
            None
        };
        
        if let Some(handle) = handle {
            commands.spawn((
                Sprite {
                    image: handle.clone(),
                    custom_size: Some(Vec2::new(400.0, 600.0)),
                    ..default()
                },
                Transform::from_translation(Vec3::new(200.0, 0.0, 0.0)),
                CharacterSprite,
            ));
        }
    }
}

fn ui_system(
    mut commands: Commands,
    display_state: Res<DisplayState>,
    assets: Res<RavenAssets>,
    monitor: Res<MemoryMonitor>,
    memory_query: Query<Entity, With<MemoryText>>,
    status_query: Query<Entity, With<StatusText>>,
    instruction_query: Query<Entity, With<InstructionText>>,
) {
    if !display_state.show_ui {
        // æ¸…é™¤æ‰€æœ‰UI
        for entity in memory_query.iter().chain(status_query.iter()).chain(instruction_query.iter()) {
            commands.entity(entity).despawn();
        }
        return;
    }
    
    // æ¸…é™¤æ—§UI
    for entity in memory_query.iter().chain(status_query.iter()).chain(instruction_query.iter()) {
        commands.entity(entity).despawn();
    }
    
    // è·å–å½“å‰å†…å­˜
    let current_memory = monitor.memory_history.last().unwrap_or(&0.0);
    
    // å†…å­˜æ˜¾ç¤º
    commands.spawn((
        Text::new(format!("ğŸ’¾ æ˜¾å­˜: {:.1}MB", current_memory)),
        TextFont {
            font_size: 20.0,
            ..default()
        },
        TextColor(Color::srgb(1.0, 1.0, 1.0)), // ç™½è‰²
        Node {
            position_type: PositionType::Absolute,
            top: Val::Px(10.0),
            left: Val::Px(10.0),
            ..default()
        },
        MemoryText,
    ));
    
    // çŠ¶æ€æ˜¾ç¤º
    let status_text = match assets.loading_status {
        LoadingStatus::NotStarted => "çŠ¶æ€: â³ æœªå¼€å§‹ (æŒ‰LåŠ è½½)".to_string(),
        LoadingStatus::Loading => "çŠ¶æ€: ğŸ”„ æ­£åœ¨åŠ è½½...".to_string(),
        LoadingStatus::Completed => "çŠ¶æ€: âœ… åŠ è½½å®Œæˆ".to_string(),
        LoadingStatus::Error(ref e) => format!("çŠ¶æ€: âŒ é”™è¯¯: {}", e),
    };
    
    commands.spawn((
        Text::new(status_text),
        TextFont {
            font_size: 18.0,
            ..default()
        },
        TextColor(Color::srgb(1.0, 1.0, 0.0)), // é»„è‰²
        Node {
            position_type: PositionType::Absolute,
            top: Val::Px(40.0),
            left: Val::Px(10.0),
            ..default()
        },
        StatusText,
    ));
    
    // æ“ä½œè¯´æ˜
    let instructions = if assets.loading_status == LoadingStatus::Completed {
        "L:åŠ è½½ | M:UI | 1-4:èƒŒæ™¯ | Q/W/E/R:è§’è‰² | C:æ¸…é™¤"
    } else {
        "L:å¼€å§‹åŠ è½½èµ„æº | M:åˆ‡æ¢UIæ˜¾ç¤º"
    };
    
    commands.spawn((
        Text::new(instructions),
        TextFont {
            font_size: 14.0,
            ..default()
        },
        TextColor(Color::srgb(0.7, 0.7, 0.7)), // ç°è‰²
        Node {
            position_type: PositionType::Absolute,
            bottom: Val::Px(10.0),
            left: Val::Px(10.0),
            ..default()
        },
        InstructionText,
    ));
}
```

## æœ€å°çš„æ¡ˆä¾‹
```rust
use bevy::prelude::*;

fn main() {
    App::new()
        .insert_resource(ClearColor(Color::BLACK))
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup)
        .run();
}

fn setup(mut commands: Commands) {
    // åˆ›å»ºä¸€ä¸ªç›¸æœº
    commands.spawn(Camera2d);


    commands.spawn((Node {
        width: Val::Px(100.0),
        height: Val::Px(200.0),
        ..default()
    },
     BackgroundColor(Color::srgb(1.0, 1.0, 0.4)),
));

}
```