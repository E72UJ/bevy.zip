---
title: bevy 序列化数据存储
date: 2025-11-07 22:17:02
tags:
id: 2
---
```rust
use bevy::camera::visibility;
use bevy::prelude::*;
use bevy::window::WindowResized;

// 虚拟屏幕的配置
#[derive(Resource)]
struct CanvasConfig {
    width: f32,
    height: f32,
}

// UI缩放资源
#[derive(Resource)]
struct VirtualScreenScale {
    scale: f32,
    offset_x: f32,
    offset_y: f32,
}

#[derive(Component)]
pub struct StartGameButton;

#[derive(Component)]
pub struct SettingsButton;

#[derive(Component)]
pub struct LoadGameButton;

#[derive(Component)]
pub struct LoadButton;

#[derive(Component)]
pub struct HelpButton;

#[derive(Component)]
pub struct AboutButton;

#[derive(Component)]
pub struct ExitGameButton;

// 标记需要缩放的UI元素，存储原始尺寸
#[derive(Component)]
pub struct ScalableUI {
    original_width: f32,
    original_height: f32,
    original_font_size: Option<f32>,
    original_margin: UiRect,
    original_padding: UiRect,
    original_gap: f32,
}

impl ScalableUI {
    fn new() -> Self {
        Self {
            original_width: 0.0,
            original_height: 0.0,
            original_font_size: None,
            original_margin: UiRect::all(Val::Px(0.0)),
            original_padding: UiRect::all(Val::Px(0.0)),
            original_gap: 0.0,
        }
    }

    fn with_size(mut self, width: f32, height: f32) -> Self {
        self.original_width = width;
        self.original_height = height;
        self
    }

    fn with_font_size(mut self, font_size: f32) -> Self {
        self.original_font_size = Some(font_size);
        self
    }

    fn with_margin(mut self, margin: UiRect) -> Self {
        self.original_margin = margin;
        self
    }

    fn with_padding(mut self, padding: UiRect) -> Self {
        self.original_padding = padding;
        self
    }

    fn with_gap(mut self, gap: f32) -> Self {
        self.original_gap = gap;
        self
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                resolution: (1280, 720).into(),
                resizable: true,
                ..default()
            }),
            ..default()
        }))
        .insert_resource(CanvasConfig {
            width: 1280.0,
            height: 720.0,
        })
        .insert_resource(VirtualScreenScale { 
            scale: 1.0,
            offset_x: 0.0,
            offset_y: 0.0,
        })
        .add_systems(Startup, setup)
        .add_systems(Update, (window_resize_system, player_movement_system))
        .run();
}

fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
    // 创建摄像机
    commands.spawn(Camera2d);
    
    // 背景图片
    commands.spawn((
        Name::new("Player"),
        Sprite {
            image: asset_server.load("main.png"), 
            custom_size: Some(Vec2::new(1280.0, 720.0)),
            ..default()
        },
        Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),
    ));

    // 文本框
    commands.spawn((
        Name::new("textbox"),
        Sprite {
            image: asset_server.load("textbox.png"), 
            custom_size: Some(Vec2::new(1920.0, 210.0)),
            ..default()
        },
        Transform::from_translation(Vec3::new(0.0, 220.0, 10.0)),
        Visibility::Visible,
    ));

    commands.spawn((
        Node {
            width: Val::Px(1280.0), // 虚拟屏幕宽度
            height: Val::Px(720.0), // 虚拟屏幕高度
            position_type: PositionType::Absolute,
            left: Val::Px(0.0),
            top: Val::Px(0.0),
            ..default()
        },
        GlobalZIndex(100),
        ScalableUI::new().with_size(1280.0, 720.0),
        children![
            // 左侧菜单区域
            (
                Node {
                    width: Val::Px(640.0), 
                    height: Val::Px(720.0),
                    align_items: AlignItems::Start,
                    justify_content: JustifyContent::Center,
                    flex_direction: FlexDirection::Column,
                    padding: UiRect {
                        left: Val::Px(50.0),
                        right: Val::Px(30.0),
                        top: Val::Px(100.0),
                        bottom: Val::Px(70.0),
                    },
                    row_gap: Val::Px(20.0),
                    ..default()
                },
                ScalableUI::new()
                    .with_size(640.0, 720.0)
                    .with_padding(UiRect {
                        left: Val::Px(50.0),
                        right: Val::Px(30.0),
                        top: Val::Px(100.0),
                        bottom: Val::Px(70.0),
                    })
                    .with_gap(20.0),
                children![
                    // Logo文本
                    (
                        Text::new("Raven engine"),
                        TextFont {
                            font: asset_server.load("fonts/SarasaFixedHC-Regular.ttf"),
                            font_size: 2.0,
                            ..default()
                        },
                        Node {
                            margin: UiRect {
                                left: Val::Px(20.0),
                                bottom: Val::Px(30.0),
                                ..default()
                            },
                            ..default()
                        },
                        GlobalZIndex(110),
                        ScalableUI::new()
                            .with_font_size(28.0)
                            .with_margin(UiRect {
                                left: Val::Px(20.0),
                                bottom: Val::Px(30.0),
                                ..default()
                            }),
                    ),
                    // 菜单按钮
                    create_button(&asset_server, "开始游戏", StartGameButton),
                    create_button(&asset_server, "关于", AboutButton),
                    create_button(&asset_server, "帮助", HelpButton),
                    create_button(&asset_server, "退出", ExitGameButton),
                ],
            ),
        ],
    ));
}

// 创建按钮
fn create_button(asset_server: &AssetServer, text: &str, button_type: impl Component) -> impl Bundle {
    (
        button_type,
        Button,
        Node {
            width: Val::Px(200.0),
            height: Val::Px(35.0),
            margin: UiRect {
                left: Val::Px(1.0),
                bottom: Val::Px(5.0),
                ..default()
            },
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            ..default()
        },
        BackgroundColor(Color::srgba(0.0, 0.0, 0.0, 0.0)),
        GlobalZIndex(55),
        ScalableUI::new()
            .with_size(200.0, 35.0)
            .with_margin(UiRect {
                left: Val::Px(1.0),
                bottom: Val::Px(1.0),
                ..default()
            }),
        children![(
            Text::new(text),
            TextFont {
                font: asset_server.load("fonts/SarasaFixedHC-Light.ttf"),
                font_size: 26.0,
                ..default()
            },
            ScalableUI::new().with_font_size(26.0),
        )]
    )
}
fn window_resize_system(
    mut resize_events: MessageReader<WindowResized>,
    mut camera_query: Query<&mut Projection, With<Camera2d>>,
    mut ui_query: Query<(&mut Node, &ScalableUI)>,
    mut text_query: Query<(&mut TextFont, &ScalableUI), With<Text>>,
    canvas_config: Res<CanvasConfig>,
    mut virtual_scale: ResMut<VirtualScreenScale>,
) {
    for event in resize_events.read() {
        println!("窗口大小改变: 宽度 = {}, 高度 = {}", event.width, event.height);

        let window_width = event.width;
        let window_height = event.height;
        let virtual_width = canvas_config.width;
        let virtual_height = canvas_config.height;

        // 计算缩放比例 - 选择较小的比例以确保内容完全可见
        let scale_x = window_width / virtual_width;
        let scale_y = window_height / virtual_height;
        let scale = scale_x.min(scale_y);

        // 计算居中偏移
        let scaled_width = virtual_width * scale;
        let scaled_height = virtual_height * scale;
        let offset_x = (window_width - scaled_width) / 2.0;
        let offset_y = (window_height - scaled_height) / 2.0;

        // 更新虚拟屏幕缩放
        virtual_scale.scale = scale;
        virtual_scale.offset_x = offset_x;
        virtual_scale.offset_y = offset_y;

        // 更新摄像机投影 - 2D精灵使用不同的缩放逻辑
        let camera_scale = 1.0 / scale;
        for mut projection in camera_query.iter_mut() {
            if let Projection::Orthographic(ortho) = projection.as_mut() {
                ortho.scale = camera_scale;
            }
        }

        // 更新所有UI元素
        for (mut node, scalable_ui) in ui_query.iter_mut() {
            // 缩放尺寸
            if scalable_ui.original_width > 0.0 {
                node.width = Val::Px(scalable_ui.original_width * scale);
            }
            if scalable_ui.original_height > 0.0 {
                node.height = Val::Px(scalable_ui.original_height * scale);
            }

            // 缩放边距
            node.margin = scale_ui_rect(&scalable_ui.original_margin, scale);
            
            // 缩放内边距
            node.padding = scale_ui_rect(&scalable_ui.original_padding, scale);
            
            // 缩放间距
            if scalable_ui.original_gap > 0.0 {
                node.row_gap = Val::Px(scalable_ui.original_gap * scale);
                node.column_gap = Val::Px(scalable_ui.original_gap * scale);
            }

            if scalable_ui.original_width == virtual_width && scalable_ui.original_height == virtual_height {
                node.left = Val::Px(offset_x);
                node.top = Val::Px(offset_y);
            }
        }

        // 更新文本大小
        for (mut text_font, scalable_ui) in text_query.iter_mut() {
            if let Some(original_font_size) = scalable_ui.original_font_size {
                text_font.font_size = original_font_size * scale;
            }
        }

    }
}

fn scale_ui_rect(rect: &UiRect, scale: f32) -> UiRect {
    UiRect {
        left: scale_val(&rect.left, scale),
        right: scale_val(&rect.right, scale),
        top: scale_val(&rect.top, scale),
        bottom: scale_val(&rect.bottom, scale),
    }
}

// 辅助函数：缩放Val
fn scale_val(val: &Val, scale: f32) -> Val {
    match val {
        Val::Px(px) => Val::Px(*px * scale),
        Val::Percent(percent) => Val::Percent(*percent), // 百分比保持不变
        _ => *val,
    }
}

fn player_movement_system(
    keyboard_input: Res<ButtonInput<KeyCode>>,
    mut query: Query<&mut Transform, With<Sprite>>,
    time: Res<Time>,
) {
    if let Some(mut player_transform) = query.iter_mut().next() {
        let mut direction = Vec3::ZERO;

        if keyboard_input.pressed(KeyCode::KeyW) {
            direction.y += 1.0;
        }
        if keyboard_input.pressed(KeyCode::KeyS) {
            direction.y -= 1.0;
        }
        if keyboard_input.pressed(KeyCode::KeyA) {
            direction.x -= 1.0;
        }
        if keyboard_input.pressed(KeyCode::KeyD) {
            direction.x += 1.0;
        }

        if direction.length() > 0.0 {
            player_transform.translation += direction.normalize() * 200.0 * time.delta_secs();
        }
    }
}
```