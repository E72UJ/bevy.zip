---
title: 9
date: 2025-11-19 03:59:47
tags:
---
<!-- 存储一个版本的档案 -->
```
extends Node2D

@onready var dialogue_box: Control = $UILayer/DialogueBox
@onready var name_label: Label = $UILayer/DialogueBox/NameBox/NameLabel
@onready var dialogue_text: RichTextLabel = $UILayer/DialogueBox/DialogueText

@onready var character_layer: CanvasLayer = $CharacterLayer
@onready var character_container: Control = $CharacterLayer/CharacterContainer
@onready var left_character: TextureRect = $CharacterLayer/CharacterContainer/left

@onready var choice_container: Control = $CanvasLayer/ChoiceContainer
@onready var choice_buttons: Array[Button] = [
	$CanvasLayer/ChoiceContainer/Choice1,
	$CanvasLayer/ChoiceContainer/Choice2,
	$CanvasLayer/ChoiceContainer/Choice3,
	$CanvasLayer/ChoiceContainer/Choice4
]

# 语音播放器
@onready var voice_player: AudioStreamPlayer2D = $VoicePlayer

# 添加白色闪烁背景相关变量
var flash_layer: CanvasLayer = null
var flash_rect: ColorRect = null
var flash_tween: Tween = null

# 闪烁效果配置
var flash_duration: float = 0.15       
var flash_intensity: float = 0.8       
var flash_interval: float = 2.0        
var auto_flash_enabled: bool = true   

# 场景切换时闪烁配置
var scene_flash_intensity: float = 2.0  
var scene_flash_duration: float = 1.2   

# 游戏状态
var game_state: String = "exploring"

# 对话分支系统
var dialogue_branches: Dictionary = {}
var current_branch_id: String = ""
var choice_history: Array = []
var current_choice_data: Array = []

# 按钮样式配置
var button_text_margin_left: int = 20
var button_text_margin_top: int = 5

# 角色管理系统
var character_database: Dictionary = {}
var current_characters: Dictionary = {}  
var character_positions: Array[String] = ["left", "center", "right"]

# 立绘动画配置
var character_fade_duration: float = 0.3
var character_slide_duration: float = 0.4
var speaking_character_scale: float = 1.05
var non_speaking_character_alpha: float = 0.7

# 动画防抖相关
var character_tweens: Dictionary = {}  
var is_switching_character: bool = false
var last_click_time: float = 0.0
var click_debounce_time: float = 0.1  

var enable_character_animations: bool = false

var scene_tree: SceneTree = null
var current_scene_path: String = ""

# ===== 新增：存档系统相关变量 =====
var save_data: Dictionary = {}
var save_slots: int = 10  # 存档槽数量
var auto_save_enabled: bool = true
var save_file_path: String = "user://save_game_{slot}.save"

# ===== 新增：自动前进系统 =====
var auto_advance_enabled: bool = false
var auto_advance_speed: float = 2.0  # 自动前进间隔时间
var auto_advance_timer: Timer = null
var auto_advance_after_voice: bool = true  # 语音播放完后自动前进

# ===== 新增：对话历史和返回系统 =====
var dialogue_history: Array = []  # 对话历史记录
var max_history_size: int = 100   # 最大历史记录数量
var can_go_back: bool = true      # 是否允许返回
var current_history_index: int = -1  # 当前在历史中的位置

# ===== 新增：快捷键和UI控制 =====
var quick_save_slot: int = 0  # 快速存档槽
var ui_visible: bool = true   # UI是否可见
var skip_mode: bool = false   # 跳过模式

func _ready():
	scene_tree = get_tree()
	current_scene_path = get_tree().current_scene.scene_file_path
	if dialogue_box:
		dialogue_box.gui_input.connect(_on_dialogue_click)
	
	setup_flash_background()
	setup_character_database()
	setup_character_positions()
	setup_choice_buttons()
	setup_choice_container()
	setup_dialogue_branches()
	setup_auto_advance_timer()
	load_game_settings()
	start_game()

# ===== 自动前进系统 =====
func setup_auto_advance_timer():
	"""设置自动前进计时器"""
	auto_advance_timer = Timer.new()
	auto_advance_timer.wait_time = auto_advance_speed
	auto_advance_timer.one_shot = true
	auto_advance_timer.timeout.connect(_on_auto_advance_timeout)
	add_child(auto_advance_timer)

func _on_auto_advance_timeout():
	"""自动前进超时回调"""
	if auto_advance_enabled and game_state == "dialogue":
		if not choice_container.visible:  # 不在选择界面时才自动前进
			advance_dialogue()

func start_auto_advance():
	"""开始自动前进"""
	if not auto_advance_enabled:
		return
	
	# 如果启用语音后自动前进，检查语音是否在播放
	if auto_advance_after_voice and voice_player and voice_player.playing:
		# 等待语音播放完成
		voice_player.finished.connect(_on_voice_finished, CONNECT_ONE_SHOT)
	else:
		# 直接开始计时器
		auto_advance_timer.start()

func _on_voice_finished():
	"""语音播放完成回调"""
	if auto_advance_enabled:
		auto_advance_timer.start()

func toggle_auto_advance():
	"""切换自动前进状态"""
	auto_advance_enabled = !auto_advance_enabled
	if not auto_advance_enabled:
		auto_advance_timer.stop()
	print("自动前进: ", "开启" if auto_advance_enabled else "关闭")

func set_auto_advance_speed(speed: float):
	"""设置自动前进速度"""
	auto_advance_speed = clamp(speed, 0.5, 10.0)
	auto_advance_timer.wait_time = auto_advance_speed
	print("自动前进速度设置为: ", auto_advance_speed, "秒")

# ===== 对话历史和返回系统 =====
func add_to_dialogue_history(dialogue_data: Dictionary):
	"""添加对话到历史记录"""
	var history_entry = {
		"branch_id": current_branch_id,
		"line_index": dialogue_box.current_line,
		"dialogue_data": dialogue_data.duplicate(),
		"characters_state": current_characters.duplicate(true),
		"timestamp": Time.get_ticks_msec()
	}
	
	dialogue_history.append(history_entry)
	
	# 限制历史记录大小
	if dialogue_history.size() > max_history_size:
		dialogue_history.pop_front()
	
	# 重置历史索引
	current_history_index = dialogue_history.size() - 1

func go_back_in_dialogue():
	"""返回上一句对话"""
	if not can_go_back or dialogue_history.is_empty():
		print("无法返回")
		return
	
	if current_history_index > 0:
		current_history_index -= 1
		var history_entry = dialogue_history[current_history_index]
		restore_dialogue_from_history(history_entry)
		print("返回到上一句对话")
	else:
		print("已经是最早的对话")

func go_forward_in_dialogue():
	"""前进到下一句对话（在历史中）"""
	if current_history_index < dialogue_history.size() - 1:
		current_history_index += 1
		var history_entry = dialogue_history[current_history_index]
		restore_dialogue_from_history(history_entry)
		print("前进到下一句对话")
	else:
		print("已经是最新的对话")

func restore_dialogue_from_history(history_entry: Dictionary):
	"""从历史记录恢复对话状态"""
	# 停止自动前进
	auto_advance_timer.stop()
	
	# 恢复分支和行数
	current_branch_id = history_entry["branch_id"]
	dialogue_box.current_line = history_entry["line_index"]
	
	# 恢复角色状态
	clear_all_characters()
	var characters_state = history_entry["characters_state"]
	for position in characters_state.keys():
		var char_data = characters_state[position]
		show_character(char_data["name"], {
			"position": position,
			"expression": char_data["expression"],
			"no_animation": true
		})
	
	# 显示对话内容
	var dialogue_data = history_entry["dialogue_data"]
	if name_label:
		name_label.text = dialogue_data["name"]
	if dialogue_text:
		dialogue_text.text = dialogue_data["text"]
	
	# 设置名字颜色
	if character_database.has(dialogue_data["name"]):
		var character_data = character_database[dialogue_data["name"]]
		if name_label:
			name_label.add_theme_color_override("font_color", character_data.get("text_color", Color.WHITE))

# ===== 存档系统 =====
func create_save_data() -> Dictionary:
	"""创建存档数据"""
	var save_dict = {
		# 基础游戏状态
		"game_state": game_state,
		"current_scene_path": current_scene_path,
		"timestamp": Time.get_datetime_string_from_system(),
		
		# 对话状态
		"current_branch_id": current_branch_id,
		"current_line": dialogue_box.current_line if dialogue_box else 0,
		"choice_history": choice_history.duplicate(true),
		"dialogue_history": dialogue_history.duplicate(true),
		"current_history_index": current_history_index,
		
		# 角色状态
		"current_characters": current_characters.duplicate(true),
		
		# 游戏设置
		"auto_advance_enabled": auto_advance_enabled,
		"auto_advance_speed": auto_advance_speed,
		"enable_character_animations": enable_character_animations,
		
		# 当前对话框内容（如果在对话中）
		"current_dialogue_data": {}
	}
	
	# 如果正在对话中，保存当前对话内容
	if game_state == "dialogue" and dialogue_box and dialogue_box.current_dialogue.size() > dialogue_box.current_line:
		save_dict["current_dialogue_data"] = dialogue_box.current_dialogue[dialogue_box.current_line].duplicate()
	
	return save_dict

func save_game(slot: int = 0) -> bool:
	"""保存游戏到指定槽位"""
	if slot < 0 or slot >= save_slots:
		print("无效的存档槽位: ", slot)
		return false
	
	var save_dict = create_save_data()
	var save_path = save_file_path.format({"slot": slot})
	
	var save_file = FileAccess.open(save_path, FileAccess.WRITE)
	if save_file == null:
		print("无法创建存档文件: ", save_path)
		return false
	
	save_file.store_string(JSON.stringify(save_dict))
	save_file.close()
	
	print("游戏已保存到槽位 ", slot, " : ", save_path)
	return true

func load_game(slot: int = 0) -> bool:
	"""从指定槽位读取游戏"""
	if slot < 0 or slot >= save_slots:
		print("无效的存档槽位: ", slot)
		return false
	
	var save_path = save_file_path.format({"slot": slot})
	
	if not FileAccess.file_exists(save_path):
		print("存档文件不存在: ", save_path)
		return false
	
	var save_file = FileAccess.open(save_path, FileAccess.READ)
	if save_file == null:
		print("无法打开存档文件: ", save_path)
		return false
	
	var save_text = save_file.get_as_text()
	save_file.close()
	
	var json = JSON.new()
	var parse_result = json.parse(save_text)
	
	if parse_result != OK:
		print("存档文件格式错误")
		return false
	
	var save_dict = json.data
	return apply_save_data(save_dict)

func apply_save_data(save_dict: Dictionary) -> bool:
	try:
		game_state = save_dict.get("game_state", "exploring")
		current_branch_id = save_dict.get("current_branch_id", "")
		choice_history = save_dict.get("choice_history", [])
		dialogue_history = save_dict.get("dialogue_history", [])
		current_history_index = save_dict.get("current_history_index", -1)
		
		# 恢复设置
		auto_advance_enabled = save_dict.get("auto_advance_enabled", false)
		auto_advance_speed = save_dict.get("auto_advance_speed", 2.0)
		enable_character_animations = save_dict.get("enable_character_animations", false)
		set_auto_advance_speed(auto_advance_speed)
		
		# 如果保存的场景与当前场景不同，需要切换场景
		var saved_scene = save_dict.get("current_scene_path", "")
		if saved_scene != "" and saved_scene != current_scene_path:
			# 保存当前存档数据，场景切换后恢复
			save_data = save_dict
			get_tree().change_scene_to_file(saved_scene)
			return true
		
		# 恢复角色状态
		clear_all_characters()
		var characters_state = save_dict.get("current_characters", {})
		for position in characters_state.keys():
			var char_data = characters_state[position]
			show_character(char_data["name"], {
				"position": position,
				"expression": char_data["expression"],
				"no_animation": true
			})
		
		# 恢复对话状态
		if game_state == "dialogue":
			var saved_line = save_dict.get("current_line", 0)
			var current_dialogue_data = save_dict.get("current_dialogue_data", {})
			
			if dialogue_branches.has(current_branch_id):
				dialogue_box.start_dialogue(dialogue_branches[current_branch_id]["dialogue"])
				dialogue_box.current_line = saved_line
				dialogue_box.show_dialogue_box()
				
				# 恢复对话框内容
				if current_dialogue_data.size() > 0:
					if name_label:
						name_label.text = current_dialogue_data.get("name", "")
					if dialogue_text:
						dialogue_text.text = current_dialogue_data.get("text", "")
					
					# 设置名字颜色
					var speaker_name = current_dialogue_data.get("name", "")
					if character_database.has(speaker_name):
						var character_data = character_database[speaker_name]
						if name_label:
							name_label.add_theme_color_override("font_color", character_data.get("text_color", Color.WHITE))
		
		print("存档读取成功")
		return true
		
	except:
		print("存档数据应用失败")
		return false

func quick_save():
	"""快速保存"""
	save_game(quick_save_slot)
	# 可以添加UI提示
	print("快速保存完成")

func quick_load():
	"""快速读取"""
	if load_game(quick_save_slot):
		print("快速读取完成")
	else:
		print("快速读取失败")

func auto_save():
	"""自动保存"""
	if auto_save_enabled:
		var auto_save_slot = save_slots - 1  # 使用最后一个槽位作为自动保存
		save_game(auto_save_slot)
		print("自动保存完成")

func get_save_info(slot: int) -> Dictionary:
	"""获取存档信息"""
	var save_path = save_file_path.format({"slot": slot})
	
	if not FileAccess.file_exists(save_path):
		return {}
	
	var save_file = FileAccess.open(save_path, FileAccess.READ)
	if save_file == null:
		return {}
	
	var save_text = save_file.get_as_text()
	save_file.close()
	
	var json = JSON.new()
	if json.parse(save_text) == OK:
		var save_dict = json.data
		return {
			"timestamp": save_dict.get("timestamp", ""),
			"scene_path": save_dict.get("current_scene_path", ""),
			"branch_id": save_dict.get("current_branch_id", ""),
			"exists": true
		}
	
	return {}

func delete_save(slot: int) -> bool:
	"""删除指定槽位的存档"""
	var save_path = save_file_path.format({"slot": slot})
	
	if FileAccess.file_exists(save_path):
		DirAccess.remove_absolute(save_path)
		print("存档已删除: ", save_path)
		return true
	
	return false

# ===== 游戏设置保存 =====
func save_game_settings():
	"""保存游戏设置"""
	var settings = {
		"auto_advance_enabled": auto_advance_enabled,
		"auto_advance_speed": auto_advance_speed,
		"enable_character_animations": enable_character_animations,
		"auto_save_enabled": auto_save_enabled
	}
	
	var settings_file = FileAccess.open("user://game_settings.save", FileAccess.WRITE)
	if settings_file:
		settings_file.store_string(JSON.stringify(settings))
		settings_file.close()

func load_game_settings():
	"""读取游戏设置"""
	if FileAccess.file_exists("user://game_settings.save"):
		var settings_file = FileAccess.open("user://game_settings.save", FileAccess.READ)
		if settings_file:
			var settings_text = settings_file.get_as_text()
			settings_file.close()
			
			var json = JSON.new()
			if json.parse(settings_text) == OK:
				var settings = json.data
				auto_advance_enabled = settings.get("auto_advance_enabled", false)
				auto_advance_speed = settings.get("auto_advance_speed", 2.0)
				enable_character_animations = settings.get("enable_character_animations", false)
				auto_save_enabled = settings.get("auto_save_enabled", true)
				
				if auto_advance_timer:
					set_auto_advance_speed(auto_advance_speed)

# ===== 修改现有函数以支持新功能 =====
func show_next_dialogue_line():
	if dialogue_box.current_line < dialogue_box.current_dialogue.size() - 1:
		dialogue_box.current_line += 1
		
		var current_data = dialogue_box.current_dialogue[dialogue_box.current_line]
		var current_name = current_data["name"]
		
		# 添加到对话历史
		add_to_dialogue_history(current_data)
		
		# 处理角色动作
		if current_data.has("character_action"):
			handle_character_action(current_data["character_action"])
		else:
			focus_on_character(current_name)
		
		# 处理闪烁动作
		if current_data.has("flash_action"):
			handle_flash_action(current_data["flash_action"])
		
		play_voice(current_data)
		
		if name_label:
			name_label.text = current_name
			
			if character_database.has(current_name):
				var character_data = character_database[current_name]
				name_label.add_theme_color_override("font_color", character_data.get("text_color", Color.WHITE))
		
		dialogue_box.show_current_line()
		check_for_choices(current_data)
		
		# 开始自动前进计时
		start_auto_advance()
		
		# 自动保存（在重要对话点）
		if auto_save_enabled and dialogue_box.current_line % 5 == 0:
			auto_save()
	else:
		check_dialogue_end()

func advance_dialogue():
	# 停止自动前进计时器
	auto_advance_timer.stop()
	
	if not dialogue_box:
		return
		
	if dialogue_box.is_typing:
		complete_current_typing()
	else:
		show_next_dialogue_line()

# ===== 输入处理更新 =====
func _input(event):
	if event.is_action_pressed("ui_accept"):
		if game_state == "dialogue" and not choice_container.visible:
			advance_dialogue()
		elif game_state == "exploring":
			show_test_dialogue()
	
	if event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_F11:
				toggle_fullscreen()
			KEY_F:
				trigger_white_flash()
			KEY_G:
				if auto_flash_enabled:
					stop_auto_flash()
				else:
					start_auto_flash()
			KEY_T:
				test_scene_change()
			# 新增快捷键
			KEY_A:  # 切换自动前进
				toggle_auto_advance()
			KEY_S:  # 快速保存
				if event.ctrl_pressed:
					quick_save()
			KEY_L:  # 快速读取
				if event.ctrl_pressed:
					quick_load()
			KEY_BACKSPACE:  # 返回上一句
				if game_state == "dialogue":
					go_back_in_dialogue()
			KEY_SPACE:  # 前进（除了正常的确认键）
				if game_state == "dialogue" and not choice_container.visible:
					advance_dialogue()
			KEY_TAB:  # 切换跳过模式
				toggle_skip_mode()
			KEY_H:  # 切换UI显示
				toggle_ui_visibility()
			# 数字键1-9用于快速存档
			KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9:
				var slot = event.keycode - KEY_0 - 1
				if event.ctrl_pressed:
					save_game(slot)
				elif event.alt_pressed:
					load_game(slot)
			# 调整自动前进速度
			KEY_EQUAL:  # + 键
				if auto_advance_enabled:
					set_auto_advance_speed(auto_advance_speed - 0.5)
			KEY_MINUS:  # - 键
				if auto_advance_enabled:
					set_auto_advance_speed(auto_advance_speed + 0.5)

# ===== 新增功能函数 =====
func toggle_skip_mode():
	"""切换跳过模式"""
	skip_mode = !skip_mode
	if skip_mode:
		auto_advance_enabled = true
		set_auto_advance_speed(0.1)  # 很快的自动前进
	else:
		auto_advance_enabled = false
	print("跳过模式: ", "开启" if skip_mode else "关闭")

func toggle_ui_visibility():
	"""切换UI显示"""
	ui_visible = !ui_visible
	if dialogue_box:
		dialogue_box.visible = ui_visible
	if choice_container:
		choice_container.visible = ui_visible and choice_container.visible
	print("UI显示: ", "开启" if ui_visible else "关闭")

# 在场景切换时保存临时数据
func _notification(what):
	if what == NOTIFICATION_WM_CLOSE_REQUEST:
		save_game_settings()
		get_tree().quit()

# ===== 保持原有其他函数不变 =====
# [这里保持你原来的所有其他函数不变]

func setup_flash_background():
	"""初始化白色闪烁背景"""
	flash_layer = CanvasLayer.new()
	flash_layer.layer = 50  
	add_child(flash_layer)
	
	flash_rect = ColorRect.new()
	flash_rect.color = Color.WHITE
	flash_rect.modulate.a = 0.0  
	flash_rect.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	flash_rect.mouse_filter = Control.MOUSE_FILTER_IGNORE  
	flash_layer.add_child(flash_rect)
	
	print("白色闪烁背景已初始化")

func trigger_white_flash(intensity: float = 0.8, duration: float = 0.15):
	"""触发一次白色闪烁效果"""
	if not flash_rect:
		print("闪烁背景未初始化")
		return
	
	if flash_tween:
		flash_tween.kill()
	
	flash_tween = create_tween()
	flash_tween.tween_property(flash_rect, "modulate:a", intensity, duration * 0.3)
	flash_tween.tween_property(flash_rect, "modulate:a", 0.0, duration * 0.7)
	
	print("触发白色闪烁，强度: ", intensity)

func start_auto_flash(interval: float = 2.0, intensity: float = 0.6, duration: float = 0.2):
	"""开始自动闪烁效果"""
	auto_flash_enabled = true
	flash_interval = interval
	flash_intensity = intensity
	flash_duration = duration
	
	_auto_flash_loop()
	print("开始自动闪烁，间隔: ", interval, "s")

func stop_auto_flash():
	"""停止自动闪烁效果"""
	auto_flash_enabled = false
	
	if flash_tween:
		flash_tween.kill()
	
	if flash_rect:
		flash_rect.modulate.a = 0.0
	
	print("停止自动闪烁")

func _auto_flash_loop():
	"""自动闪烁循环"""
	if not auto_flash_enabled:
		return
	
	trigger_white_flash(flash_intensity, flash_duration)
	
	await get_tree().create_timer(flash_interval).timeout
	_auto_flash_loop()

func set_flash_background_color(color: Color):
	"""设置闪烁背景颜色"""
	if flash_rect:
		flash_rect.color = color
		print("闪烁背景颜色设置为: ", color)

func handle_flash_action(action_data: Dictionary):
	"""处理闪烁动作"""
	if not action_data.has("type"):
		return
	
	var action_type = action_data["type"]
	var intensity = action_data.get("intensity", flash_intensity)
	var duration = action_data.get("duration", flash_duration)
	var interval = action_data.get("interval", flash_interval)
	var color = action_data.get("color", Color.WHITE)
	
	match action_type:
		"single_flash":
			set_flash_background_color(color)
			trigger_white_flash(intensity, duration)
		
		"start_auto_flash":
			set_flash_background_color(color)
			start_auto_flash(interval, intensity, duration)
		
		"stop_auto_flash":
			stop_auto_flash()
		
		"continuous_flash":
			var count = action_data.get("count", 3)
			var flash_interval_time = action_data.get("flash_interval", 0.5)
			set_flash_background_color(color)
			_continuous_flash(count, intensity, duration, flash_interval_time)
		
		"scene_flash":
			set_flash_background_color(color)
			trigger_white_flash(scene_flash_intensity, scene_flash_duration)

func _continuous_flash(count: int, intensity: float, duration: float, interval: float):
	"""连续闪烁指定次数"""
	for i in range(count):
		trigger_white_flash(intensity, duration)
		if i < count - 1:  
			await get_tree().create_timer(interval).timeout

func setup_character_database():
	"""设置角色数据库"""
	character_database = {
		"奥比休斯": {
			"display_name": "奥比休斯",
			"portraits": {
				"normal": "res://assest/chapter1/characters/obicius/normal.png",
				"serious": "res://assest/chapter1/characters/obicius/normal.png",
			},
			"default_expression": "normal",
			"voice_pitch": 1.0,
			"text_color": Color("#bbf1fe")
		},
		"小赛尔": {
			"display_name": "小赛尔",
			"portraits": {
				"normal": "res://assest/chapter1/characters/saire/normal.png",
				"doubt": "res://assest/chapter1/characters/saire/doubt.png",
				"Snappy": "res://assest/chapter1/characters/saire/Snappy.png",
				"speechless": "res://assest/chapter1/characters/saire/speechless.png",
				"happy": "res://assest/chapter1/characters/saire/happy.png",
				"Friendly": "res://assest/chapter1/characters/saire/Friendly.png",
				"Arch": "res://assest/chapter1/characters/saire/Arch.png",
				"Squint": "res://assest/chapter1/characters/saire/Squint.png",
			},
			"default_expression": "normal",
			"voice_pitch": 1.2,
			"text_color":  Color("#bbf1fe")
		},
		"主角": {
			"display_name": "主角",
			"portraits": {
				"normal": "res://characters/protagonist/normal.png",
				"thinking": "res://characters/protagonist/thinking.png"
			},
			"default_expression": "normal",
			"voice_pitch": 1.0,
			"text_color": Color.WHITE
		},
		"翼灵兽": {
			"display_name": "翼灵兽",
			"portraits": {
				"normal": "res://assest/chapter1/characters/Aerialynx/normal.png",
			},
			"default_expression": "normal",
			"voice_pitch": 1.2,
			"text_color":  Color("#bbf1fe")
		},
		"约瑟(?)": {
			"display_name": "约瑟(?)",
			"portraits": {
				"normal": "res://assest/chapter1/characters/yuese/normal.png",
			},
			"default_expression": "normal",
			"voice_pitch": 1.2,
			"text_color":  Color("#bbf1fe")
		},
	}

func setup_character_positions():
	if not character_container:
		print("CharacterContainer 未找到")
		return
	
	var positions_config = {
		"left": {"anchor": Vector2(0.2, 1.0), "size": Vector2(650, 0)},
		"center": {"anchor": Vector2(0.5, 1.0), "size": Vector2(400, 800)},
		"right": {"anchor": Vector2(0.8, 1.0), "size": Vector2(400, 800)}
	}
	
	for position in character_positions:
		var position_node = character_container.get_node_or_null(position)
		
		if not position_node:
			position_node = TextureRect.new()
			position_node.name = position
			character_container.add_child(position_node)
			
			var config = positions_config[position]
			position_node.set_anchors_and_offsets_preset(Control.PRESET_BOTTOM_LEFT)
			position_node.anchor_left = config["anchor"].x - 0.1
			position_node.anchor_right = config["anchor"].x + 0.1
			position_node.anchor_top = config["anchor"].y - 0.8
			position_node.anchor_bottom = config["anchor"].y
			
			position_node.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
			position_node.visible = false
			
			print("创建角色位置节点: ", position)
		
		if position_node is TextureRect:
			position_node.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
			if position == "left" and position_node.visible:
				position_node.visible = false  

func setup_dialogue_branches():
	dialogue_branches = {
		"opening": {
			"dialogue": [
				{
					"name": "小赛尔", 
					"text": "这里是……",
					"character_action": {
						"type": "show",
						"character": "小赛尔",
						"position": "left",
						"expression": "Squint",
						"no_animation": true  
					},
					"scene_action": {
						"type": "scene_change_scene_with_transition",
						"scene_path": "res://tscn/room/r5.tscn",
						"transition": "fade"
					}
				}
			]
		}
	}
	print("对话分支已设置: ", dialogue_branches)

func handle_character_action(action_data: Dictionary):
	"""处理角色动作"""
	if not action_data.has("type"):
		return
	
	var action_type = action_data["type"]
	
	if action_type.begins_with("scene_"):
		handle_scene_action(action_data)
		return
	
	if not action_data.has("character"):
		return
	
	var character_name = action_data["character"]
	
	match action_type:
		"show":
			show_character(character_name, action_data)
		"hide":
			hide_character(character_name, action_data)
		"change_expression":
			change_character_expression(character_name, action_data.get("expression", "normal"))
		"focus":
			focus_on_character(character_name)
		"move":
			move_character(character_name, action_data)

func show_character(character_name: String, action_data: Dictionary):
	if not character_database.has(character_name):
		print("角色不存在: ", character_name)
		return
	
	var character_data = character_database[character_name]
	var position = action_data.get("position", "center")
	var expression = action_data.get("expression", character_data["default_expression"])
	var animation_type = action_data.get("animation", "fade_in")
	
	var position_node = get_character_position_node(position)
	if not position_node:
		print("角色位置节点不存在: ", position)
		return
	stop_character_animation(position)
	
	var portrait_path = character_data["portraits"].get(expression, character_data["portraits"][character_data["default_expression"]])
	var texture = load(portrait_path)
	if not texture:
		print("无法加载立绘: ", portrait_path)
		return
	
	position_node.texture = texture
	
	current_characters[position] = {
		"name": character_name,
		"expression": expression,
		"node": position_node
	}
	
	if enable_character_animations:
		play_character_animation(position_node, animation_type)
	else:
		position_node.visible = true
		position_node.modulate.a = 1.0

func hide_character(character_name: String, action_data: Dictionary):
	"""隐藏角色立绘"""
	var animation_type = action_data.get("animation", "fade_out")
	
	for position in current_characters.keys():
		if current_characters[position]["name"] == character_name:
			var position_node = current_characters[position]["node"]
			play_character_animation(position_node, animation_type)
			
			await get_tree().create_timer(character_fade_duration).timeout
			current_characters.erase(position)
			break

func change_character_expression(character_name: String, expression: String):
	if not character_database.has(character_name):
		return
	
	var character_data = character_database[character_name]
	
	for position in current_characters.keys():
		if current_characters[position]["name"] == character_name:
			var position_node = current_characters[position]["node"]
			
			var portrait_path = character_data["portraits"].get(expression, character_data["portraits"][character_data["default_expression"]])
			var texture = load(portrait_path)
			if texture:
				if enable_character_animations:
					var tween = create_tween()
					tween.tween_property(position_node, "modulate:a", 0.0, 0.1)
					tween.tween_callback(func(): position_node.texture = texture)
					tween.tween_property(position_node, "modulate:a", 1.0, 0.1)
				else:
					position_node.texture = texture
				
				current_characters[position]["expression"] = expression
			break

func focus_on_character(character_name: String):
	"""聚焦到说话的角色"""
	for position in current_characters.keys():
		var character_info = current_characters[position]
		var position_node = character_info["node"]
		var is_speaking = character_info["name"] == character_name
		
		var tween = create_tween()
		tween.parallel().tween_property(position_node, "modulate:a", 1.0 if is_speaking else non_speaking_character_alpha, character_fade_duration)
		tween.parallel().tween_property(position_node, "scale", Vector2.ONE * (speaking_character_scale if is_speaking else 1.0), character_fade_duration)

func move_character(character_name: String, action_data: Dictionary):
	"""移动角色到新位置"""
	var new_position = action_data.get("new_position", "center")
	var animation_type = action_data.get("animation", "slide")
	
	var old_position = ""
	for position in current_characters.keys():
		if current_characters[position]["name"] == character_name:
			old_position = position
			break
	
	if old_position == "":
		print("角色不在场景中: ", character_name)
		return
	
	var character_info = current_characters[old_position]
	current_characters.erase(old_position)
	
	show_character(character_name, {
		"position": new_position,
		"expression": character_info["expression"],
		"animation": animation_type
	})

func play_character_animation(character_node: TextureRect, animation_type: String):
	"""播放角色动画"""
	var tween = create_tween()
	
	var original_position = character_node.position
	
	match animation_type:
		"fade_in":
			character_node.modulate.a = 0.0
			character_node.visible = true
			tween.tween_property(character_node, "modulate:a", 1.0, character_fade_duration)
		
		"fade_out":
			tween.tween_property(character_node, "modulate:a", 0.0, character_fade_duration)
			tween.tween_callback(func(): character_node.visible = false)
		
		"slide_in_left":
			var offset_x = -200
			character_node.position.x += offset_x
			character_node.modulate.a = 0.0
			character_node.visible = true
			tween.parallel().tween_property(character_node, "position:x", original_position.x, character_slide_duration)
			tween.parallel().tween_property(character_node, "modulate:a", 1.0, character_fade_duration)
		
		"slide_in_right":
			var offset_x = 200
			character_node.position.x += offset_x
			character_node.modulate.a = 0.0
			character_node.visible = true
			tween.parallel().tween_property(character_node, "position:x", original_position.x, character_slide_duration)
			tween.parallel().tween_property(character_node, "modulate:a", 1.0, character_fade_duration)
		
		"bounce":
			var original_scale = character_node.scale
			tween.tween_property(character_node, "scale", original_scale * 1.1, 0.1)
			tween.tween_property(character_node, "scale", original_scale, 0.1)

func get_character_position_node(position: String) -> TextureRect:
	"""获取角色位置节点"""
	if not character_container:
		return null
	return character_container.get_node_or_null(position)

func clear_all_characters():
	"""清空所有角色"""
	for position in current_characters.keys():
		var position_node = current_characters[position]["node"]
		position_node.visible = false
		position_node.modulate.a = 1.0
		position_node.scale = Vector2.ONE
	current_characters.clear()

func setup_choice_buttons():
	for i in range(choice_buttons.size()):
		if choice_buttons[i]:
			choice_buttons[i].pressed.connect(_on_choice_button_pressed.bind(i))
			setup_button_text_margin(choice_buttons[i])

func setup_button_text_margin(button: Button):
	if not button:
		return
	
	button.add_theme_constant_override("text_margin_left", button_text_margin_left)
	button.add_theme_constant_override("text_margin_top", button_text_margin_top)

func setup_choice_container():
	if choice_container:
		choice_container.visible = false

func _on_dialogue_click(event: InputEvent):
	if game_state != "dialogue":
		return
	
	if choice_container and choice_container.visible:
		return
	
	if event is InputEventMouseButton:
		if event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
			advance_dialogue()

func complete_current_typing():
	if dialogue_box.has_method("stop_typing"):
		dialogue_box.stop_typing()
	elif dialogue_box.has_signal("typing_finished"):
		dialogue_box.emit_signal("typing_finished")
	
	if dialogue_box.current_dialogue.size() > dialogue_box.current_line:
		var current_data = dialogue_box.current_dialogue[dialogue_box.current_line]
		var current_text = current_data["text"]
		var current_name = current_data["name"]
		
		if current_data.has("character_action"):
			handle_character_action(current_data["character_action"])
		
		if current_data.has("flash_action"):
			handle_flash_action(current_data["flash_action"])
		
		play_voice(current_data)
		
		if dialogue_text:
			dialogue_text.text = current_text
		elif dialogue_box.has_method("get_dialogue_label"):
			var label = dialogue_box.get_dialogue_label()
			if label:
				label.text = current_text
		
		if name_label:
			name_label.text = current_name
		
		if dialogue_box.has_method("set_typing_finished"):
			dialogue_box.set_typing_finished()
		else:
			dialogue_box.is_typing = false

func check_for_choices(dialogue_data: Dictionary):
	if dialogue_data.has("choices") and dialogue_data["choices"].size() > 0:
		show_choices(dialogue_data["choices"])

func check_dialogue_end():
	var current_data = dialogue_box.current_dialogue[dialogue_box.current_line]
	print("检查对话结束，当前数据: ", current_data)
	
	if current_data.has("scene_action"):
		print("发现场景动作: ", current_data["scene_action"])
		handle_scene_action(current_data["scene_action"])
		return
	
	if current_data.has("end_dialogue") and current_data["end_dialogue"]:
		on_dialogue_end()

func show_choices(choices: Array):
	current_choice_data = choices
	hide_all_choice_buttons()
	
	for i in range(min(choices.size(), choice_buttons.size())):
		if choice_buttons[i]:
			choice_buttons[i].text = choices[i]["text"]
			choice_buttons[i].visible = true
	
	choice_container.visible = true

func hide_all_choice_buttons():
	for button in choice_buttons:
		if button:
			button.visible = false

func _on_choice_button_pressed(button_index: int):
	if button_index >= current_choice_data.size():
		return
	
	var choice_data = current_choice_data[button_index]
	print("玩家选择了: ", choice_data["text"])
	
	choice_history.append({
		"branch": current_branch_id,
		"line": dialogue_box.current_line,
		"choice_index": button_index
	})
	
	hide_choices()
	
	if choice_data.has("jump_back") and choice_data["jump_back"]:
		handle_jump_back()
	elif choice_data.has("jump_to"):
		var target_branch = choice_data["jump_to"]
		var target_line = choice_data.get("line", 0)
		jump_to_branch(target_branch, target_line)

func handle_jump_back():
	if choice_history.size() > 1:
		choice_history.pop_back()
		var previous_state = choice_history.pop_back()
		
		jump_to_branch(previous_state["branch"], previous_state["line"])
		
		var current_dialogue_data = dialogue_branches[current_branch_id]["dialogue"]
		if previous_state["line"] < current_dialogue_data.size():
			var line_data = current_dialogue_data[previous_state["line"]]
			if line_data.has("choices"):
				show_choices(line_data["choices"])
	else:
		print("无法回退，已经在起始位置")

func jump_to_branch(branch_id: String, start_line: int = 0):
	if not dialogue_branches.has(branch_id):
		print("分支不存在: ", branch_id)
		return
	
	current_branch_id = branch_id
	var branch_data = dialogue_branches[branch_id]
	
	dialogue_box.start_dialogue(branch_data["dialogue"])
	dialogue_box.current_line = start_line
	
	if start_line < branch_data["dialogue"].size():
		dialogue_box.show_current_line()
		
		var current_data = branch_data["dialogue"][start_line]
		
		if current_data.has("character_action"):
			handle_character_action(current_data["character_action"])
		
		if current_data.has("flash_action"):
			handle_flash_action(current_data["flash_action"])
		
		play_voice(current_data)
		
		if name_label:
			name_label.text = current_data["name"]
		
		check_for_choices(current_data)

func hide_choices():
	if choice_container:
		choice_container.visible = false
	hide_all_choice_buttons()

func play_voice(dialogue_data: Dictionary):
	if not voice_player:
		print("语音播放器未找到")
		return
	
	if dialogue_data.has("voice") and dialogue_data["voice"] != "":
		var voice_path = dialogue_data["voice"]
		
		if voice_player.playing:
			voice_player.stop()
		
		var voice_stream = load(voice_path)
		if voice_stream:
			voice_player.stream = voice_stream
			voice_player.play()
			print("播放语音: " + voice_path)
		else:
			print("无法加载语音文件: " + voice_path)

func start_game():
	# 如果有待恢复的存档数据，恢复它
	if save_data.size() > 0:
		apply_save_data(save_data)
		save_data.clear()
	else:
		show_opening_dialogue()

func show_opening_dialogue():
	game_state = "dialogue"
	current_branch_id = "opening"
	choice_history.clear()
	clear_all_characters()
	
	jump_to_branch("opening", 0)
	dialogue_box.show_dialogue_box()

func _process(delta):
	if game_state == "dialogue":
		if not choice_container.visible:
			if dialogue_box.current_dialogue.is_empty() or dialogue_box.current_line >= dialogue_box.current_dialogue.size():
				on_dialogue_end()

func on_dialogue_end():
	if voice_player and voice_player.playing:
		voice_player.stop()
	
	stop_auto_flash()
	
	dialogue_box.hide_dialogue_box()
	hide_choices()
	clear_all_characters()
	game_state = "exploring"
	print("对话结束，可以自由探索了")

func show_test_dialogue():
	show_opening_dialogue()

func toggle_fullscreen():
	if DisplayServer.window_get_mode() == DisplayServer.WINDOW_MODE_WINDOWED:
		DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_FULLSCREEN)
		print("进入全屏模式")
	else:
		DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_WINDOWED)
		print("退出全屏模式")

func _on_clickarea_pressed() -> void:
	if game_state == "dialogue" and not choice_container.visible:
		advance_dialogue()
	elif game_state == "exploring":
		show_test_dialogue()
		
func stop_character_animation(position: String):
	if character_tweens.has(position) and character_tweens[position]:
		character_tweens[position].kill()
		character_tweens.erase(position)

func handle_scene_action(action_data: Dictionary):
	var action_type = action_data.get("type", "")
	print("处理场景动作: ", action_type)
	
	match action_type:
		"scene_change_scene":  
			change_scene(action_data.get("scene_path", ""))
		"scene_change_scene_with_transition": 
			change_scene_with_transition(
				action_data.get("scene_path", ""), 
				action_data.get("transition", "fade")
			)
		"scene_reload_scene": 
			reload_current_scene()

func change_scene(scene_path: String):
	if scene_path == "":
		print("场景路径为空")
		return
	
	if not FileAccess.file_exists(scene_path):
		print("场景文件不存在: ", scene_path)
		return
	
	print("开始场景切换到: ", scene_path)
	
	trigger_white_flash(scene_flash_intensity, scene_flash_duration)
	
	cleanup_before_scene_change()
	
	get_tree().change_scene_to_file(scene_path)

func change_scene_with_transition(scene_path: String, transition_type: String = "fade"):
	"""带过渡效果的场景切换"""
	if scene_path == "":
		print("场景路径为空")
		return
	
	print("开始带过渡的场景切换到: ", scene_path)
	
	trigger_white_flash(scene_flash_intensity, scene_flash_duration)
	
	create_scene_transition(transition_type, func(): 
		get_tree().change_scene_to_file(scene_path)
	)

func reload_current_scene():
	print("重新加载当前场景")
	
	trigger_white_flash(scene_flash_intensity, scene_flash_duration)
	
	cleanup_before_scene_change()
	get_tree().reload_current_scene()

func cleanup_before_scene_change():
	"""场景切换前的清理工作"""
	print("清理场景切换前的状态")
	
	if voice_player and voice_player.playing:
		voice_player.stop()
	
	auto_flash_enabled = false
	
	for position in character_tweens.keys():
		stop_character_animation(position)
	character_tweens.clear()
	
	if dialogue_box:
		dialogue_box.hide_dialogue_box()
	if choice_container:
		choice_container.visible = false
	
	game_state = "exploring"

func create_scene_transition(transition_type: String, callback: Callable):
	"""创建场景过渡效果"""
	var transition_layer = CanvasLayer.new()
	transition_layer.layer = 100  
	add_child(transition_layer)
	
	var transition_rect = ColorRect.new()
	transition_rect.color = Color.BLACK
	transition_rect.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	transition_layer.add_child(transition_rect)
	
	match transition_type:
		"fade":
			transition_rect.modulate.a = 0.0
			var tween = create_tween()
			tween.tween_property(transition_rect, "modulate:a", 1.0, 0.5)
			tween.tween_callback(callback)
		
		"slide_left":
			transition_rect.position.x = get_viewport().size.x
			var tween = create_tween()
			tween.tween_property(transition_rect, "position:x", 0.0, 0.5)
			tween.tween_callback(callback)
		
		"slide_right":
			transition_rect.position.x = -get_viewport().size.x
			var tween = create_tween()
			tween.tween_property(transition_rect, "position:x", 0.0, 0.5)
			tween.tween_callback(callback)
		
		_:  
			transition_rect.modulate.a = 0.0
			var tween = create_tween()
			tween.tween_property(transition_rect, "modulate:a", 1.0, 0.5)
			tween.tween_callback(callback)

func test_scene_change():
	"""测试场景切换"""
	print("测试场景切换")
	handle_scene_action({
		"type": "scene_change_scene_with_transition",
		"scene_path": "res://tscn/room/r4.tscn",
		"transition": "fade"
	})
```


## 存储按钮节点设计
BottomMenuUI (Control)
├── Background (NinePatchRect)
└── ButtonContainer (HBoxContainer)
    ├── RollbackButton (TextureButton)
    ├── SaveButton (TextureButton)
    ├── LoadButton (TextureButton)
    ├── QuickSaveButton (TextureButton)
    ├── QuickLoadButton (TextureButton)
    ├── SettingsButton (TextureButton)
    ├── AutoButton (TextureButton)
    ├── SkipButton (TextureButton)
    ├── HistoryButton (TextureButton)
    └── HideButton (TextureButton)